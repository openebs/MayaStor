use snafu::Snafu;
use spdk_sys::{spdk_poller, spdk_poller_register, spdk_poller_unregister};
use std::{ops::Deref, os::raw::c_void};

#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("Failed to create poller"))]
    CreatePoller {},
}

/// NewType wrapper around the spdk_poller. NewTypes are preferred over
/// structure wrappings as they impose no overhead.
#[derive(Debug)]
pub struct PollTask(*mut spdk_poller);

impl Default for PollTask {
    fn default() -> Self {
        Self(std::ptr::null_mut())
    }
}

impl Drop for PollTask {
    fn drop(&mut self) {
        if !self.0.is_null() {
            trace!("deregister poller {:?}", self.0);
            unsafe {
                spdk_poller_unregister(&mut self.0);
            }
        }
    }
}

/// struct that holds the whole context of the function
///
/// # Example:
///
/// ```ignore
/// use mayastor::poller::SetTimeout;
/// #[derive(Default, Debug)]
/// struct Mayargs {
///     value: i32
/// };
/// SetTimeout::usec(Mayargs::default(), |ctx| println!("count: {}" ctx.value), 1_000_000);
/// ```
#[derive(Debug, Default)]
pub struct SetTimeout<F, T> {
    poller: PollTask,
    ctx: T,
    f: F,
}

impl<F, T> SetTimeout<F, T> {
    /// execute the given closure `F` after `delay` in usec with
    /// context/arguments by provided by `T`
    pub fn usec(ctx: T, f: F, delay: u64)
    where
        F: FnOnce(T),
    {
        extern "C" fn unwrap<F, T>(arg: *mut c_void) -> i32
        where
            F: FnOnce(T),
        {
            let c: Box<SetTimeout<F, T>> =
                unsafe { Box::from_raw(arg as *mut SetTimeout<F, T>) };

            (c.f)(c.ctx);
            0
        }

        let mut event = Box::new(Self {
            poller: PollTask::default(),
            ctx,
            f,
        });

        // we only execute this function once
        let ptr = &*event as *const _ as *mut c_void;
        let poller = unsafe {
            spdk_poller_register(Some(unwrap::<F, T>), ptr as *mut _, delay)
        };

        event.poller = PollTask(poller);
        trace!("registered poller {:?}", event.poller);
        std::mem::forget(event);
    }
}

/// signature of the poll function, this is similar as the function generated by
/// bindgen but does not require the user of this interface to deal with the
/// Option<T>.
pub type PollFunction = extern "C" fn(*mut c_void) -> i32;

/// register a new function to be executed periodically with the interval `usec`
pub fn register_poller<T: Deref + std::fmt::Debug>(
    poll_fn: PollFunction,
    ctx: T,
    usec: u64,
) -> Result<PollTask, Error> {
    // first try to see if we can create the poller to begin with
    let ptr = &*ctx as *const _ as *mut c_void;
    let poller = unsafe { spdk_poller_register(Some(poll_fn), ptr, usec) };

    if poller.is_null() {
        return Err(Error::CreatePoller {});
    }

    std::mem::forget(ctx);
    Ok(PollTask(poller))
}
