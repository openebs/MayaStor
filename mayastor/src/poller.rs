use crate::bdev::nexus::Error;
use spdk_sys::{spdk_poller, spdk_poller_register, spdk_poller_unregister};
use std::{ops::Deref, os::raw::c_void};

/// NewType wrapper around the spdk_poller. NewTypes are preferred over
/// structure wrappings as they impose no overhead.
#[derive(Debug)]
pub struct PollTask(*mut spdk_poller);

impl Default for PollTask {
    fn default() -> Self {
        Self(std::ptr::null_mut())
    }
}

impl Drop for PollTask {
    fn drop(&mut self) {
        if !self.0.is_null() {
            trace!("deregister poller {:?}", self.0);
            unsafe {
                spdk_poller_unregister(&mut self.0);
            }
        }
    }
}

/// Execute a function on the reactor once, after given the interval
#[derive(Debug, Default)]
pub struct SetTimeout<F, T> {
    poller: PollTask,
    ctx: T,
    f: F,
}

impl<F, T> SetTimeout<F, T> {
    /// execute the given closure `F` after `delay` with context/arguments given
    /// by `T`
    pub fn usec(ctx: T, f: F, delay: u64)
    where
        F: FnOnce(T),
    {
        extern "C" fn unwrap<F, T>(arg: *mut c_void) -> i32
        where
            F: FnOnce(T),
        {
            let c: Box<SetTimeout<F, T>> =
                unsafe { Box::from_raw(arg as *mut SetTimeout<F, T>) };

            (c.f)(c.ctx);
            0
        }

        let mut event = Box::new(Self {
            poller: PollTask::default(),
            ctx,
            f,
        });

        let ptr = &*event as *const _ as *mut c_void;
        let poller = unsafe {
            spdk_poller_register(Some(unwrap::<F, T>), ptr as *mut _, delay)
        };

        event.poller = PollTask(poller);
        trace!("registered poller {:?}", event.poller);
        std::mem::forget(event);
    }
}

/// signature of the poll function, this is similar as the function generated by
/// bindgen but does not require the user of this interface to deal with the
/// Option
pub type PollFunction = extern "C" fn(*mut c_void) -> i32;

/// register a new function to be executed periodically with the interval `usec`
pub fn register_poller<T: Deref + std::fmt::Debug>(
    poll_fn: PollFunction,
    ctx: T,
    usec: u64,
) -> Result<PollTask, Error> {
    // first try to see if we can create the poller to begin with
    let ptr = &*ctx as *const _ as *mut c_void;
    let poller = unsafe { spdk_poller_register(Some(poll_fn), ptr, usec) };

    if poller.is_null() {
        return Err(Error::Internal("failed to create poller".into()));
    }

    std::mem::forget(ctx);
    Ok(PollTask(poller))
}
